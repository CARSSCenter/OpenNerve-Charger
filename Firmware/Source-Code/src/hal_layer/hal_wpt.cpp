/**
 * @name Hornet / WPT Charger
 * @file hal_wpt.cpp
 * @brief WPT Hardware Abstraction Layer for nrf52840
 *
 * @copyright Copyright (c) 2024
 *
 */

#include "hal_wpt.h"

#include "hal_adc.h"
#include "hal_gpio.h"
#include "hal_pinout.h"
#include "hal_timer.h"
#include "svc_wpt_manager.h"
#include "eda_manager_log_config.h"

#include <cmath>
#include <cstdint>
#include <cstdio>
namespace hal
{
    Wpt_LTC4125::Wpt_LTC4125() : mDac(), timerImon(mtimerImonConfig, nullptr, this),
                                 timerNtc(mtimerNtcConfig, nullptr, this)
    {
        ConfigureDac();
        //  Initialize the WPT module by setting the DAC values
        //  this need to be donde before enabling the WPT module
        Init();
    }
    // mDac(),

    MeasurementReadyCallback_t Wpt_LTC4125::mImonReadyCallback = nullptr;

    void Wpt_LTC4125::Init(void)
    {
        SetDeltaFBThreshold();

        SetFrequencyThreshold();

        SetPulseWidthThreshold(VoltageMinPulseWidthThreshold_mV);

        SetMinimunDriverPulseWidth();
    }

    void Wpt_LTC4125::Enable(void)
    {
        // Enable the WPT module
        Gpio::Write(PIN_WPT_EN, 0);
    }

    void Wpt_LTC4125::Disable(void)
    {
        // Disable the WPT module
        Gpio::Write(PIN_WPT_EN, 1);
    }

    void Wpt_LTC4125::StopSearch(void)
    {
        // Stop the WPT power search
        // Write 1 to the CTD pin to stop the search
    }

    void Wpt_LTC4125::ResumeSearch(void)
    {
        // Restart the WPT power search
        // Write 0 to the CTD pin to resume the search
    }

    void Wpt_LTC4125::SetDeltaFBThreshold(void)
    {
        // Delta FB Threshold Input. This pin is used to adjust the minimum detected
        // power step size in the transmit power search to find the optimum transmitter
        // power operating point. The default setting (pin shorted to IN) ensures proper
        // operation in most systems. However, in very low power or very weakly coupled
        // systems a smaller step size may be desired.
        mDac.SetOutput(hal::Channel::CHANNEL_3, VoltageDeltaFBThreshold);
    }

    void Wpt_LTC4125::SetFrequencyThreshold(void)
    {
        // Frequency Threshold Input. This pin is used to program the primary foreign
        // object detection method. A resonant driving frequency exceeding the programmed
        // value indicates the presence of a large conductive object in the field space
        // generated by the transmit coil. If a frequency fault is detected, power delivery
        // will immediately stop until the next transmit power search.
        mDac.SetOutput(hal::Channel::CHANNEL_2, VoltageFrequencyThreshold);
    }

    void Wpt_LTC4125::SetPulseWidthThreshold(uint16_t voltage_mv)
    {
        // Pulse Width Threshold One Pin. The positive pulse width waveform on the SW1(SW2)
        // pin is proportional to the voltage on this pin.
        mDac.SetOutput(hal::Channel::CHANNEL_1, voltage_mv);
    }

    uint8_t Wpt_LTC4125::GetMaxPulseWidthThresholdStep(void)
    {
        return MAX_VOLTAGE_STEP_PULSE_WIDTH;
    }

    void Wpt_LTC4125::SetPulseWidthThresholdStep(uint8_t step)
    {
        // Validate the step parameter
        if (step > MAX_VOLTAGE_STEP_PULSE_WIDTH)
        {
            SetPulseWidthThreshold(VoltageMaxPulseWidthThreshold_mV);
        }
        else
        {
            // Calculate voltage based on step
            uint16_t voltage_mv = VoltageMinPulseWidthThreshold_mV + (step * VoltageStepPulseWidthThreshold_mV);

            // Set the DAC output to the calculated voltage
            SetPulseWidthThreshold(voltage_mv);
        }
    }

    void Wpt_LTC4125::SetMinimunDriverPulseWidth(void)
    {
        // Minimum Driver Pulse Width Input. The voltage value on this pin determines the
        // minimum driver pulse width value used in the transmit power search. The driver
        // pulse width corresponds to transmit power. Shorting this pin to GND sets the
        // pulse width of the first step in the search to 1/32 of the natural period of
        // the transmitting LC tank. A faster transmit power search can be implemented when
        // it is known that low transmit power (corresponding to the 1/32 period pulse width)
        // is not sufficient to meet the requirements of the receiver load.
        mDac.SetOutput(hal::Channel::CHANNEL_0, VoltageMinimunDriverPulseWidth);
    }

    void Wpt_LTC4125::StartMeasureImon(void)
    {
        static hal::Adc::AdcChannel channel = {
            .pin = PIN_WPT_IMON,
        };
        static int16_t wpt_imon_voltage = 0;

        hal::Adc& m_adc = hal::Adc::get_instance();

        m_adc.take_measurement(&channel, &wpt_imon_voltage);

        svc::WptManager &wptManager = svc::WptManager::Instance();
        wptManager.mWptImonVoltage = wpt_imon_voltage;
    }

    void Wpt_LTC4125::StopMeasureImon(void)
    {
        //  TODO: Delete this 
    }

    void Wpt_LTC4125::StartMeasureNtc(void)
    {
        static hal::Adc::AdcChannel channel = {
            .pin = PIN_WPT_NTC,
        };
        static int16_t wpt_ntc_voltage = 0;

        hal::Adc& m_adc = hal::Adc::get_instance();

        m_adc.take_measurement(&channel, &wpt_ntc_voltage);

        svc::WptManager &wptManager = svc::WptManager::Instance();
        wptManager.mWptNtcVoltage = wpt_ntc_voltage;
        
        wptManager.mWptNtcTemperature = Wpt_LTC4125::NtcVoltageToTemperature(wpt_ntc_voltage);
    }

    void Wpt_LTC4125::StopMeasureNtc(void)
    {
        // TODO: Delete this 
    }

    void Wpt_LTC4125::ConfigureDac(void)
    {
        // Configure the DAC
        mDac.Init();
    }

    void Wpt_LTC4125::GetNtc()
    {
        StartMeasureNtc();
    }

    int16_t Wpt_LTC4125::NtcVoltageToTemperature(int32_t Vout_mV) {
        // Calculate NTC resistance
        const int16_t R_FIXED = 5000;  // Fixed resistor of the voltage divider: Vout = VCC (R_NTC / (R_FIXED + R_NTC))
        if (VCC_mV <= Vout_mV) return -273; // Prevent division by zero
        int32_t R_NTC = (int32_t)R_FIXED * Vout_mV / (VCC_mV - Vout_mV);

        // Apply Steinhart-Hart equation: T = 1 / (1/T0 + 1/B * ln(R_NTC/R0))
        // R0 = 5000
        int32_t log_R = (int32_t)(log((float)R_NTC / 5000.0) * 1); // multiply for precision in fixed-point arithmetic, avoiding floating-point errors while still using int
        int32_t temp_mK = T0_mK * NTC_BETA / (NTC_BETA + (T0_mK * log_R / 1000));
        // Convert to Â°C
        return (int16_t)((temp_mK - 273150) / 1000);
    }

    void Wpt_LTC4125::GetImon(MeasurementReadyCallback_t callback)
    {
        mImonReadyCallback = callback;

        StartMeasureImon();
    }

    uint8_t Wpt_LTC4125::GetStat(void)
    {
        // Get the Status of the WPT module
        // TODO : The ticket for HSD-285 was created to investigate the IC response.
        uint8_t statRead = 0;

        return statRead;
    }

    void Wpt_LTC4125::wptImonCallback(const void *context)
    {
        const Wpt_LTC4125 *instance = static_cast<const Wpt_LTC4125 *>(context);
        // Callback for Imon Adc Pin
        int16_t imonVoltage = 0;
        for (uint8_t i = 0; i < instance->AdcBufferSize; i++)
        {
            imonVoltage += instance->mImon[i];
        }
        imonVoltage /= instance->AdcBufferSize;

        const_cast<Wpt_LTC4125 *>(instance)->StopMeasureImon();

        const_cast<Wpt_LTC4125 *>(instance)->mimonVoltage = imonVoltage;

        if (instance->mImonReadyCallback)
        {
            instance->mImonReadyCallback(imonVoltage);
        }
    }

    void Wpt_LTC4125::wptNtcCallback(const void *context)
    {
        const Wpt_LTC4125 *instance = static_cast<const Wpt_LTC4125 *>(context);
        // Callback for NTC Adc Pin
        int16_t ntcValue = 0;
        for (uint8_t i = 0; i < instance->AdcBufferSize; i++)
        {
            ntcValue += instance->mNtc[i];
        }
        ntcValue /= instance->AdcBufferSize;

        const_cast<Wpt_LTC4125 *>(instance)->StopMeasureNtc();

        const_cast<Wpt_LTC4125 *>(instance)->mNtcValue = ntcValue;

        if (instance->mNtcReadyCallback)
        {
            instance->mNtcReadyCallback(ntcValue);
        }
    }
} // namespace hal
